/*
 * (c) Copyright 2023-2025 exec Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * KineticFire Labs: https://labs.kineticfire.com/
 *     project site:  https://github.com/kineticfire-labs/exec/
 *
 */


 import org.cyclonedx.model.OrganizationalContact
 import org.cyclonedx.model.License
 import org.cyclonedx.model.AttachmentText

plugins {
    // needed for Spock
    id 'groovy'
    id 'java-library'
    id 'maven-publish'
    id 'signing'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0'
    alias(libs.plugins.license)
    alias(libs.plugins.cyclonedx)
}

// properties that define versions the MUST be set; set on command line with -Pproperty=value
def requiredVersionPropertyList = ['exec_lib_version']

// tasks that require the version property to be set
def versionRequiredTasks = [
    'build', 'assemble', 'jar', 'sourcesJar', 'javadocJar',
    'publish', 'publishToMavenLocal', 'publishToSonatype',
    'publishMavenPublicationToSonatypeRepository',
    'publishMavenPublicationToMavenLocalRepository',
    'sign', 'signMavenPublication',
    'closeAndReleaseSonatypeStagingRepository', 'closeSonatypeStagingRepository',
    'cyclonedxBom'
]

group = 'com.kineticfire'
version = (findProperty('exec_lib_version') ?: '0.0.0-SNAPSHOT').toString()

// throw exception, stopping build, if property doesn't satisfy version format
// only check when running tasks that actually need the version
if (isVersionRequiredForRequestedTasks(versionRequiredTasks)) {
    checkRequiredVersionPropertyList( requiredVersionPropertyList )
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral( )
}

dependencies {
    // Use the latest Groovy version for Spock testing
    testImplementation libs.bundles.testing
    testRuntimeOnly libs.junit.platform.launcher
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of( getProperty( 'javaLanguage_version' ) as Integer )
    }
    withSourcesJar()
    withJavadocJar()
}

tasks.named( 'test' ) {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform( )
}

javadoc {
    options.bottom = "Copyright (c) ${project_copyrightYears} KineticFire.  All rights reserved."
}

def commonJarManifestMap = [
        'Implementation-Vendor'  : 'KineticFire Labs',
        'Implementation-Project' : "${project_title}",
        'Implementation-Title'   : "${exec_lib_title}",
        'Implementation-Version' : "${version}",
        'Implementation-URL'     : 'https://github.com/kineticfire-labs/exec/'
    ]

def classesJarManifestMap = [:]
classesJarManifestMap.putAll( commonJarManifestMap )
classesJarManifestMap.put( 'Name', 'com/kineticfire/exec/' )
classesJarManifestMap.put( 'Sealed', 'true' )

jar {
    archiveBaseName = "${exec_lib_name}"

    manifest {
        attributes(
            classesJarManifestMap
        )
    }

    from( rootProject.projectDir ) {
        include 'LICENSE/'
    }
}

tasks.named('sourcesJar') {
    archiveBaseName = "${exec_lib_name}"
    archiveVersion  = project.version
    manifest { attributes(commonJarManifestMap) }
    from(rootProject.projectDir) { include 'LICENSE/' }
}

tasks.named('javadocJar') {
    archiveBaseName = "${exec_lib_name}"
    archiveVersion  = project.version
    manifest { attributes(commonJarManifestMap) }
    from(rootProject.projectDir) { include 'LICENSE/' }
}

license {
    header = rootProject.file( 'resources' + File.separator + 'LICENSE_HEADER' )
    excludes( ["**/generated/**/*.java"] )
    mapping( 'java', 'SLASHSTAR_STYLE' )
}

cyclonedxBom {

    OrganizationalContact organizationalContact = new OrganizationalContact()
    organizationalContact.setEmail( 'hello@kineticfire.com' )

    organizationalEntity = {oe->
        oe.name = 'KineticFire Labs'
        oe.url = ['https://labs.kineticfire.com/', 'https://github.com/kineticfire-labs/exec/']
        oe.addContact( organizationalContact )
    }

    projectType = 'library'

    outputName = "${exec_lib_name}-${version}-cyclonedx"

    includeConfigs = ['implementation']
    skipConfigs = ['testImplementation', 'testRuntimeOnly', 'api']

    AttachmentText attachmentText = new AttachmentText( )
    attachmentText.setText( "Copyright (c) ${project_copyrightYears} KineticFire. All rights reserved.  Licensed under the Apache License, Version 2.0.  See included 'LICENSE' file or license URL." )

    License license = new License( )
    license.setLicenseText( attachmentText )
    license.setId( 'Apache-2.0' )
    license.setUrl( 'https://www.apache.org/licenses/LICENSE-2.0' )
    licenseChoice = {lc->
        lc.addLicense( license )
    }
}

publishing {
    publications {
        maven(MavenPublication) {
            artifactId = "${exec_lib_name}"

            from components.java

            pom {
                name = "${exec_lib_title}"
                description = 'A Java library for simplifying native system process execution and shell script validation'
                url = 'https://github.com/kineticfire-labs/exec'
                licenses {
                    license {
                        name = 'Apache License, Version 2.0'
                        url = 'https://www.apache.org/licenses/LICENSE-2.0'
                        distribution = 'repo'
                    }
                }
                developers {
                    developer {
                        id = 'kineticfire-labs'
                        name = 'KineticFire Labs'
                        email = 'hello@kineticfire.com'
                        organization = 'KineticFire Labs'
                        organizationUrl = 'https://labs.kineticfire.com/'
                    }
                }
                scm {
                    // small nit: the ssh form should be either ssh URL or colon form, e.g.:
                    connection = 'scm:git:ssh://git@github.com/kineticfire-labs/exec.git'
                    developerConnection = 'scm:git:ssh://git@github.com/kineticfire-labs/exec.git'
                    url = 'https://github.com/kineticfire-labs/exec'
                }
                issueManagement {
                    system = 'GitHub Issues'
                    url = 'https://github.com/kineticfire-labs/exec/issues'
                }
            }
        }
    }
}

signing {
    useGpgCmd()
    sign publishing.publications
}

nexusPublishing {
    repositories {
        sonatype {
            nexusUrl.set(uri('https://ossrh-staging-api.central.sonatype.com/service/local/'))
            snapshotRepositoryUrl.set(uri('https://central.sonatype.com/repository/maven-snapshots/'))
            stagingProfileId = group
            username.set(providers.gradleProperty('centralPortalUsername'))
            password.set(providers.gradleProperty('centralPortalPassword'))
        }
    }
    transitionCheckOptions {
        maxRetries.set(60)
        delayBetween.set(java.time.Duration.ofSeconds(5))
    }
}

build.finalizedBy( 'cyclonedxBom' )

/**
 * Determines if the version property is required based on the requested tasks.
 * 
 * @param versionRequiredTasks List of task names that require the version property
 * @return true if any of the requested tasks require the version property, false otherwise
 */
def isVersionRequiredForRequestedTasks(versionRequiredTasks) {
    def requestedTasks = gradle.startParameter.taskNames
    return versionRequiredTasks.any { requiredTask ->
        requestedTasks.contains(requiredTask)
    }
}

/**
 * Checks that required properties' values adhere to the required format, throwing an error if not.
 * <p>
 * A valid format is 'latest' or:
 * <ul>
 *    <li>takes the form &lt;number&gt;.&lt;number&gt;.&lt;number&gt; where the series of three numbers separated by
 *    dots would typically represent &lt;major&gt;.&lt;minor&gt;.&lt;fix&gt;</li>
 *    <li>each 'number' is a non-negative integer consisting of one or more digits 0-9 such that a number cannot have a
 *    leading '0' (but a 'number' can be exactly '0')</li>
 * </ul>
 *
 * <p>Errors if not set.</p>
 *
 * @param propertyList
 *    a list of String properties to check
 */
void checkRequiredVersionPropertyList( propertyList ) {

    for ( String property : propertyList ) {

        if ( project.hasProperty( property ) ) {

            String value = project[property]

            if ( ( value ==~ /(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)/ ) || value ==~ /latest/ ) {
                println "Property defined, setting:  $property=$value"
            } else {
                throw new GradleException( "Value for property $property did match required format." )
            }

        } else {
            throw new GradleException( "Required property '$property' is missing. Pass it on the command line, " +
                    "e.g. -P$property=1.0.0");
        }
    }
}